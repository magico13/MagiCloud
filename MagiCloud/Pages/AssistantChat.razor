@page "/chat"
@page "/chat/{Id}"
@using MagiCloud.Services;
@using MagiCloud;
@using MagiCloud.Services.ChatServices;
@using MagiCommon.Comparers.ElasticFileInfoComparers;
@using MagiCommon.Extensions
@using MagiCommon.Interfaces;
@using MagiCommon.Models.AssistantChat;
@using Markdig;
@using Microsoft.AspNetCore.Authorization;
@using Microsoft.AspNetCore.Components.Authorization;
@using OpenAI.Responses;
@using System.Text;
@using System.Text.Json;

@attribute [Authorize]

@inject IChatCompletionService ChatCompletionService
@inject IElasticFileRepo ElasticManager
@inject ChatAssistantCommandHandler ChatAssistantCommandHandler

<h2>Chat with Assistant</h2>
@if (Chat is null)
{
    if (ForbiddenMessage is not null)
    {
        <Paragraph>@ForbiddenMessage</Paragraph>
    }
    else
    {
        <Paragraph>The assistant is analyzing your documents... Please wait...</Paragraph>
    }
}
else
{
    <Card>
        <CardBody>
            @foreach(var item in Chat.ConversationHistory.Skip(1)) @* Skip system message *@
            {
                @if (item is MessageResponseItem messageItem)
                {
                    var isUserMessage = messageItem.Role == MessageRole.User;
                    var textContent = string.Join("\n", 
                        messageItem.Content
                            .Where(c => !string.IsNullOrEmpty(c.Text))
                            .Select(c => c.Text));
                    
                    if (!string.IsNullOrEmpty(textContent))
                    {
                        var displayText = isUserMessage ? textContent : Markdown.ToHtml(textContent, MarkdownPipeline);
                        var alignment = isUserMessage ? TextAlignment.End : TextAlignment.Start;
                        var role = isUserMessage ? "User" : "Assistant";
                        
                        <Paragraph TextAlignment="@alignment">@((MarkupString)$"<b>{role}</b>: {displayText}")</Paragraph>
                    }
                }
                else if (item is FunctionCallResponseItem functionCallItem)
                {
                    <Paragraph TextAlignment="TextAlignment.Start">
                        @((MarkupString)Markdown.ToHtml($"_Invoked_ `{functionCallItem.FunctionName}` _with arguments_ `{functionCallItem.FunctionArguments}`", MarkdownPipeline))
                    </Paragraph>
                }
                else if (item is FunctionCallOutputResponseItem functionOutputItem)
                {
                    var functionText = JsonSerializer.Serialize(
                        JsonSerializer.Deserialize<object>(functionOutputItem.FunctionOutput),
                        new JsonSerializerOptions { WriteIndented = true }
                    );
                    
                    <CollapsibleBlock ButtonText="View Function Output">
                        <Paragraph>@functionText</Paragraph>
                    </CollapsibleBlock>
                }
                else if (item is ReasoningResponseItem reasoningItem)
                {
                    var summaryText = reasoningItem.GetSummaryText();
                    if (!string.IsNullOrEmpty(summaryText))
                    {
                        <CollapsibleBlock ButtonText="?? View Reasoning">
                            <Paragraph>@summaryText</Paragraph>
                        </CollapsibleBlock>
                    }
                }
            }
            <Addons>
                <Addon AddonType=AddonType.Body>
                    <TextEdit @bind-Text=UserMessage KeyUp=KeyUpHandler Role="TextRole.Text"></TextEdit>
                </Addon>
                <Addon AddonType=AddonType.End>
                    <Button Color="Color.Primary" Clicked="SendUserMessageAsync">Send</Button>
                </Addon>
            </Addons>
            @if(LastResponse is not null)
            {
                <Text>@($"Tokens: {GetTokenCount(LastResponse)}")</Text>
            }
        </CardBody>
    </Card>
}


@code {
    [CascadingParameter] 
    private Task<AuthenticationState> AuthenticationStateTask { get; set; }
    private string UserId { get; set; }
    private Chat Chat { get; set; }
    private string ForbiddenMessage { get; set; }
    private OpenAIResponse LastResponse { get; set; }

    private MarkdownPipeline MarkdownPipeline { get; set; } = new MarkdownPipelineBuilder().UseAdvancedExtensions().Build();

    [Parameter] 
    public string Id { get; set; }
    protected string UserMessage { get; set; }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (!firstRender) return;
        var authState = await AuthenticationStateTask;
        UserId = authState.User.GetUserId();

        var initialRequest = new ChatCompletionRequest
        {
            User = UserId
        };

        MagiCommon.Models.ElasticFileInfo fileContext = null;
        string additionalContext = null;

        if (!string.IsNullOrWhiteSpace(Id))
        {
            // Document chat
            var (access, file) = await ElasticManager.GetDocumentAsync(UserId, Id, false);
            if (access is not (FileAccessResult.FullAccess or FileAccessResult.ReadOnly)
                || file is null || file.IsDeleted)
            {
                ForbiddenMessage = "You do not have access to the file or the file was not found.";
                this.StateHasChanged();
                return;
            }
            fileContext = file;
        }

        // Grab some overall document stats
        var docs = await ElasticManager.GetDocumentsAsync(UserId, false);
        additionalContext = $"Number of user's files in storage: {docs.Count}. Total storage space of user's files: {docs.Sum(d => d.Size)} bytes.";

        initialRequest.Functions = new()
        {
            ChatAssistantCommandHandler.AvailableFunctionDefinitions["get_time"],
            ChatAssistantCommandHandler.AvailableFunctionDefinitions["get_text"],
            ChatAssistantCommandHandler.AvailableFunctionDefinitions["get_metadata"],
            ChatAssistantCommandHandler.AvailableFunctionDefinitions["process"],
            ChatAssistantCommandHandler.AvailableFunctionDefinitions["search"]
        };

        Chat = ChatCompletionService.CreateNewGeneralChat(
            initialRequest,
            authState.User.Identity.Name,
            UserId,
            additionalContext,
            fileContext);
        LastResponse = await Chat.StartChatAsync();
        this.StateHasChanged();
    }

    private async Task SendUserMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(UserMessage)) return;

        var msgCopy = UserMessage;
        UserMessage = null;
        var response = await Chat.SendUserMessage(msgCopy);
        
        while (response is not null)
        {
            LastResponse = response;
            response = null;

            this.StateHasChanged();
            await Task.Delay(1); // Add a delay to hopefully update the text
            
            // Check if there are any function calls to handle
            var functionCallItem = LastResponse.OutputItems
                .OfType<FunctionCallResponseItem>()
                .FirstOrDefault();
                
            if (functionCallItem is not null)
            {
                // Handle the function call directly
                response = await ChatAssistantCommandHandler.HandleFunctionCallAsync(
                    Chat, 
                    UserId, 
                    functionCallItem
                );
            }
        }
    }

    private async Task KeyUpHandler(KeyboardEventArgs keyboardEvent)
    {
        if (keyboardEvent.Key == ConsoleKey.Enter.ToString())
        {
            await SendUserMessageAsync();
        }
    }

    private int GetTokenCount(OpenAIResponse response)
    {
        // The Responses API includes usage information
        return response.Usage?.TotalTokenCount ?? 0;
    }
}