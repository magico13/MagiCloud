@using Humanizer
@using MagiCloud.DataManager;
@using MagiCommon
@using MagiCommon.Extensions
@using MagiCommon.Models;
@using Microsoft.Extensions.Logging
@using System 
@using System.IO;

@inject FileStorageService FileStorage
@inject HttpClient Client
@inject ILogger<Upload> Logger

<Heading Size=HeadingSize.Is3>Upload Files</Heading>

<FilePicker @ref=filePicker Multiple Upload=OnFileUpload ShowMode=FilePickerShowMode.List MaxChunkSize=Constants.UPLOAD_CHUNK_SIZE MaxFileSize=maxFileSize Ended=OnEnded Changed=OnFilesChanged/>
<Form>
    <Validations @ref=validations>
        <Fields>
            <Field ColumnSize=ColumnSize.IsAuto>
                <Button Color=Color.Primary Type=ButtonType.Submit Clicked=DownloadRemoteFile PreventDefaultOnSubmit>Remote Download</Button>
            </Field>
            <Validation Validator=ValidateURL>
                <Field>
                    <TextEdit @bind-Text=UrlText Placeholder="Or enter a URL to remotely download a file" />
                </Field>
            </Validation>
        </Fields>
    </Validations>
</Form>



@if (errorMessages.Any())
{
    <UnorderedList>
    @foreach (var msg in errorMessages)
    {
        <UnorderedListItem TextColor=TextColor.Danger>@msg</UnorderedListItem>
    }
    </UnorderedList>
}

@code {
    private long maxFileSize = 1024 * 1024 * 1024 * 2L; //2 GB
    private int uploaded = 0;
    private int fileCount = 0;
    private List<string> errorMessages = new();
    private FilePicker filePicker;
    private Validations validations;

    [CascadingParameter]
    private Task<AuthenticationState> AuthenticationStateTask { get; set; }
    private string UserId { get; set; }

    [Parameter]
    public EventCallback OnUploadComplete { get; set; }
    [Parameter]
    public string CurrentDirectory { get; set; }

    private string UrlText { get; set; }

    protected async override Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateTask;
        UserId = authState.User.GetUserId();
        await base.OnInitializedAsync();
    }

    private async Task OnFilesChanged(FileChangedEventArgs e)
    {
        fileCount = e.Files.Length;
        uploaded = 0;
        errorMessages.Clear();
        await Task.CompletedTask;
    }

    private async Task OnFileUpload(FileUploadEventArgs e)
    {
        var file = e.File;
        try
        {
            Logger.LogInformation("Starting upload of file {FileName} of size {Size} bytes", file.Name, file.Size);
            var curDir = string.IsNullOrWhiteSpace(CurrentDirectory) ? "/" : CurrentDirectory;
            var info = new ElasticFileInfo
            {
                Name = PathAnalog.Combine(curDir, PathAnalog.GetFileNameWithoutExtension(file.Name)),
                Extension = PathAnalog.GetExtension(file.Name),
                MimeType = file.Type,
                LastModified = file.LastModified,
                Size = file.Size
            };
            using var readStream = file.OpenReadStream(maxFileSize);
            await FileStorage.StoreFile(UserId, info, readStream);
        }
        catch (Exception ex)
        {
            Logger.LogError("File: {Filename} Error: {Error}",
                file.Name, ex.Message);
            errorMessages.Add($"{file.Name}: Error {ex.Message}");
            file.Status = FileEntryStatus.Error;
            file.ErrorMessage = ex.Message;

            // Forcibly tell the FilePicker that the upload ended without success
            await filePicker.FileEdit.UpdateFileEndedAsync(file, false, FileInvalidReason.UnexpectedError);
        }
    }

    private async Task OnEnded(FileEndedEventArgs e)
    {
        uploaded++;
        if (uploaded >= fileCount)
        {
            await OnUploadComplete.InvokeAsync();
        }
    }

    private async Task DownloadRemoteFile()
    {
        FileStream tempStream = null;
        try
        {
            if (await validations.ValidateAll() && Uri.TryCreate(UrlText, UriKind.Absolute, out var uri))
            {
                errorMessages.Clear();
                var response = await Client.GetAsync(uri);
                if (response.IsSuccessStatusCode)
                {
                    var size = response.Content.Headers.ContentLength;
                    if (size >= maxFileSize)
                    {
                        var humanizedSize = size.Value.Bytes().Humanize();
                        errorMessages.Add($"Error: File too large. {humanizedSize}");
                        Logger.LogError("Failed to remote download file from uri '{URI}'. File too large. {Size} bytes.", UrlText, size);
                        return;
                    }

                    var contentType = response.Content.Headers.ContentType?.MediaType;
                    var lastModified = response.Content.Headers.LastModified ?? DateTimeOffset.Now;
                    var name = !string.IsNullOrWhiteSpace(uri.AbsolutePath) 
                        ? uri.AbsolutePath.Trim('/').Split('/').Last() 
                        : Guid.NewGuid().ToString("N");

                    var curDir = string.IsNullOrWhiteSpace(CurrentDirectory) ? "/" : CurrentDirectory;
                    var info = new ElasticFileInfo
                    {
                        Name = PathAnalog.Combine(curDir, name),
                        Extension = null,
                        MimeType = contentType,
                        LastModified = lastModified,
                        Size = size ?? 0
                    };

                    using var stream = await response.Content.ReadAsStreamAsync();
                    await FileStorage.StoreFile(UserId, info, stream);

                    UrlText = null;
                    await validations.ClearAll();
                    await OnUploadComplete.InvokeAsync();
                }
                else
                {
                    errorMessages.Add($"Error: {response.StatusCode}({(int)response.StatusCode})");
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to remote download file from uri {URI}", UrlText);
            errorMessages.Add(ex.Message);
        }
        finally
        {
            tempStream?.Dispose();
        }
    }

    private void ValidateURL(ValidatorEventArgs e)
    {
        var urlString = e.Value?.ToString();
        if (string.IsNullOrWhiteSpace(urlString))
        {
            e.Status = ValidationStatus.None;
        }
        else
        {
            var valid = Uri.TryCreate(urlString, UriKind.Absolute, out var _);
            e.Status = valid ? ValidationStatus.Success : ValidationStatus.Error;
        }
    }
}